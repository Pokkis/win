视音频pts计算

dancing_night 2015-05-25 18:27:34  7889  收藏 4
分类专栏： ffmpeg ffmpeg学习笔记
版权
1、概述
这段时间做转码，计算pts的时候都是转换一下时间基，我就在想这个pts如果没有原来的pts做参考如何计算其值？摸索一番总算明白了头绪记录于此。
2、视频pts
视频比较好理解，就是每帧递增，假如fps是25帧的，时间基为fps的倒数1/25，那么pts递增即可。
如下：
第一帧：pts=0
第二帧：pts=1
第三帧：pts=3
.
.
.
第n帧：pts = n - 1;

。。。以此类推
计算公式为：第n帧的pts = n * (（1 / timbase）/ fps);
3、音频pts
音频相对来说更难理解一些，因为音频的一个packet不止一帧，所以一秒到底有多少个packet就不知道，就别说如何计算pts了。
假设音频一秒有num_pkt个packet，那么这个num_pkt到底是多少？
这的从音频基础开始说起，我们知道音频有个采样率，就是一秒钟采用多少次，很多音频都是44100的采样率，也有8k的，那么这个采样率和num_pkt有什么关系呢？
我们发现在AVFrame中有一个比较重要的字段叫做nb_samples，这个字段名为采样数，此字段可以结合音频数据格式计算这个frame->data有多大，其实这个字段联合采样率还可以计算音频一秒有多少个packet。
计算公式如下：
num_pkt = 采样率 / nb_samples;
这样我们就知道了音频每秒的包数目（可以见到理解为帧），有了此数据计算pts就和视频一模一样了，
计算公式如下：
第n个包的pts = n * (（1 / timbase）/ num_pkt);
很多音频时间基和采样率成倒数，那么根据公式我们的音频pts就可以很简单的以nb_samples递增了，如下：
第一个包：pts = 0 * nb_samples;
第二个包：pts = 1 * nb_samples;
第三个包：pts = 2 * nb_samples;
.
.
.
第n个包：pts = (n - 1) * nb_samples;

注：以上说的timebase为AVStream里的timebase。
原文链接：https://blog.csdn.net/dancing_night/java/article/details/45972361



##### 如何算音频PTS
以采样8000hz为例，也就是说1秒种会有8000个采样，

我的DSP采集上来的数据是以576个采样为一帧。

AudioNum = 8000/576个音频帧。

1000/AudioNum = 每个音频所占用的毫秒数（ns）

ns*90=PTS。
————————————————
版权声明：本文为CSDN博主「星辰帝威」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/nine_locks/java/article/details/48011275



一段TS流，必须包含PAT包、PMT包、多个音频包、多个视频包、多个PCR包、以及其他信息包PSI。

解析TS流数据的流程：查找PID为0x0的包，解析PAT，PAT包中的program_map_PID表示PMT的PID；查找PMT，PMT包中的elementary_PID表示音视频包的PID，PMT包中的PCR_PID表示PCR的PID，**有的时候PCR的PID跟音频或者视频的PID相同，说明PCR会融进音视频的包，注意解析，有的时候PCR是自己单独的包；CAT、NIT、SDT、EIT的PID分别为: 0x01、0x10、0x11、0x12**。

PSI被分为4个表结构，他们应被进一步划分为各个段（SECTION）并插入到传输流TS分组中，一些带有预先规定的PID，另一些带有用户可选的PID。

**TS包中净荷所承载的信息包括以下3种：**

•  **1、视频/音频的PES包以及辅助数据**

•  **2、描述单路节目复用信息的节目映射表（PMT）**

•  **3、描述单路节目复用信息的节目关联表（PAT）**



个节目可能有多个视频和音频流，解码器必须选择2个PID，一个视频流的PID（100hex），一个音频流的PID（200hex）。

此后解码器只收集这些TS包，**解复用，重新组成PES包，这些PES包再送到视频或音频解码器。**

**传输过程中TS流的结构也可能发生改变。解码端机顶盒，如DVB-S，必须连续检测TS流瞬时结构，读出PAT和PMT，做自适应调整。**

 

•  PAT和PMT读出以后，用户确定出一个节目的两个PID：

  待解码视频信号的PID（如100hex）

  待解码音频信号的PID（如200hex）

解码器只处理这两个PID的TS包：

  **解复用过程中，PID为100hex的所有TS包集合成视频PES包，送到视频解码器。**

  **同样，PID为200hex的所有TS包重新集合成音频PES包，送到音频解码器。**

如果ES流没有加扰，这时可以直接解码。

 

 对付费电视或许可证和地域限制等情况，ES流利用电子码进行传输保护。

– ES流利用各种方法进行混扰，接收端必须配有附加硬件并授权。

– 附加硬件必须有TS流中合适的解扰和授权数据。

**– 因此TS流中传送一个特殊的表CAT(conditionalaccess table)**

**• CAT提供了TS流其他数据包的PID，该数据包传送了解扰所需信息**：

– ECM(entitlement control message)   用于传送加扰码

– EMM(entitlement management message)   用于用户管理

•  只有ES流本身可以加扰，TS包头、表格和**adaptation field**不能加扰。

•  解扰本身在MPEG解码器以外的附加硬件设备进行，附加硬件与解扰方法相关，可以做成智能板卡通过CI(common interface)插入机顶盒。

•  在MPEG解码器做进一步处理之前，TS流在该硬件设备中循环。

•  ECM和EMM的信息，以及用户的个人码可以将码流解扰。

![img](http://img.my.csdn.net/uploads/201303/23/1364007469_8281.png)

– 亮度信号采样频率13.5MHz，色度信号6.75MHz。27MHz是采样频率的倍数，作为发送端MPEG编码器所有处理过程的参考或基本频率。

– 编码器中27MHz振荡器作为系统时钟(STC)的输入。

– STC是42bit计数器，由27MHz时钟计数，溢出后重新从0开始。

– 接收端也必须提供STC，其27MHz振荡器和42bit计数器必须与编码器STC完全同步。

MPEG码流中需传送参考信息——**PCR(program clock reference)，即在固定时刻将最新的STC计数器值复制到TS流中**

**•  码流中传送的PCR值必须足够多，有最大间隔的限制；而且要相对准确，没有抖动。**

**MPEG标准规定：**

**– 每个节目PCR的最大间隔为40ms。**

**– PCR的抖动小于±500ns。**

•  PCR如果出错：

– 本来应该显示彩色图像，却显示出黑白图像。

– TS流重复用时会出现抖动，因为TS包顺序改变，但其中PCR信息却没变。经常会有最大±30μs的PCR抖动，该问题许多机顶盒可以解决。

•  **PCR信息在相应节目TS包的adaptation field中传送**，而TS包类型的准确信息可以从PMT中获得。

•  节目时钟同步以后，视音频编码就可以锁定系统时钟进行了。

•  欧洲DVB项目组和美国ATSC项目组都定义了数字视音频节目传输的附加信息，以便简化机顶盒操作，使其更加人性化：

– 在TS流中传送节目名称来分辨不同节目；

•  MPEG-2为扩展留有空间，在PSI、PMT和CAT之外，**TS流中还可以有private tables，定义了用户表的结构以及如何将用户表插入到TS流中**。

 

 

**TS包**头定义：

typedef struct TS_packet_header
{
  unsigned sync_byte            : 8; //同步字节, 固定为0x47,表示后面的是一个TS分组
  unsigned transport_error_indicator    : 1; //传输误码指示符
  unsigned payload_unit_start_indicator  : 1; //有效荷载单元起始指示符

  unsigned transport_priority       : 1; //传输优先, 1表示高优先级,传输机制可能用到，解码用不着
  unsigned PID              : 13; //PID
  unsigned transport_scrambling_control  : 2; //传输加扰控制 
  unsigned adaption_field_control      : 2; //自适应控制 01仅含有效负载，10仅含调整字段，11含有调整字段和有效负载。为00解码器不进行处理
  unsigned continuity_counter        : 4; //连续计数器 一个4bit的计数器，范围0-15
} **TS_packet_header;   //总共32位，4个字节**

 

***\*TS包， 很多地方packet译为分组，即传输分组，XX分组\****

 

- **sync_byte**

是包中的第一个字节，TS包以固定的8bit的同步字节开始，所有的TS传送包，同步字都是唯一的OX47，用于建立发送端和接收端包的同步。

MPEG-2解码器接收到MPEG-2 TS流时，首先检测包结构，在TS流中查找同步字节：

总是OX47，总位于TS包开始位置，固定间隔为188字节。同时满足这两个条件，可以确定同步。

如果出现一个字节为47hex(OX47)，解码器将检测这个字节前后n倍188字节的位置是否也是同步字节。

如果是，则当前字节为同步字节；否则，当前字节只是码流中偶尔出现的47hex，不是同步字节。

接收端收到5个TS包之后开始同步。丢包3个之后解码器即失步，需重新同步。

- **transport_error_indicator**

用于从解码器向分接器指示传输误码。若这个比特被设置，表示此TS包中所携带的净荷信息有错误，无法使用。

传输错误标志位，一般传输错误的话就不会处理这个包了

- **payload_unit_start_indicator**

有效负载的开始标志
标志PES包头以及包含节目特定信息的表（PMT，PAT）的头是否出现在该包中，在失步后的重新同步中起着重要的作用
一个PES包会被封装在很多小的TS包中，该标识指示是否是一个PES包的第一个TS包，用于重新同步

- **PID**

PID是识别TS包的重要参数，用来识别TS包所承载的数据类型。在TS码流生成时，每一类业务（视频，音频，数据）的基本码流均被赋予一个不同的识别号PID，解码器借助于PID判断某一个TS包属于哪一类业务的基本码流。

​        **//0X00 -> PAT,  0x01->CAT, PMT与NIT的TS包的PID在PAT中指定**

​        **//0X1FFF->空分组、空包， 0X0002-0X000F也被保留**

​        **//ISO/IEC13818-1中定义，通过传输流传送PSI表时，****PSI应被划分为一个或多个段（SECTION）后, 将SECTION映射到传输流中进行传送，****ISO/IEC13818-1 中定义了这种传输段（SECTION）的语法结构，通过这种结构，将PSI的数据填充到传输流中进行传送. 为什么要把PSI划为多个SECTION来传输了，一次传输不就行了？ 因为每个TS包的数据负载能力是有限的，即每个TS包的长度是有限的，所以当有些PSI表很长很大时，就需要将表拆分成一个一个SECTION语法数据段，再把这钟结构的SECTION填充到TS包中进行传输** 

​       **【每一个段的长度不一，一个段的开始由TS包的有效负载中的p\**ayload_unit_start_indicator\**来标识】**

[![DVB 传输流TS 传输流语法规格](http://s6.sinaimg.cn/mw690/001Y9f7yty6GDPO0xNz05&690)](http://photo.blog.sina.com.cn/showpic.html#blogid=6b94d5680101ton7&url=http://album.sina.com.cn/pic/001Y9f7yty6GDPO0xNz05)

 

 

  if (adaption_field_control == '10' || adaption_field_control == '11')

  {

​    adaption_fields() //调整字段的处理

  }

  if (adaption_field_control == '01' || adaption_field_control == '11')

  {

​    for(i = 0; i < N ; i++) //**N值 = 184 - 调整字段的字节数**

​    {

​    }

  }  

 

- t**ransport_scrambling_control**

传送信息通过加入扰码来加密，各个基本码流可以独立进行加扰。加扰控制字段说明TS包中的净荷数据是否加扰。如果加扰，标志出解扰的密匙。

 

- **adaption_field_control**

```
调整字段控制
　　　0x0: // reserved for future use by ISO/IEC 
     0x1: // 无调整字段，仅含有效负载    
     0x2: // 仅含调整字段，无有效负载 
     0x3: // 调整字段后含有效负载 适配域是一个可变长度的域，它在TS包中是否存在，由适配域控制标识决定。
```

- **continuity_counter**

用于对传输误码进行检测。在发送端对所有的包都做0-15的循环计数，在接收终端，如发现循环计数器的值有中断，表明数据在传输中有丢失。

 

 

 

============

TS包头解析：

oid adjust_TS_packet_header(TS_packet_header* pheader)
{
  unsigned char buf[4]; 
  memcpy(buf, pheader, 4);
  pheader->transport_error_indicator    = buf[1] >> 7;
  pheader->payload_unit_start_indicator  = buf[1] >> 6 & 0x01;
  pheader->transport_priority        = buf[1] >> 5 & 0x01;
  pheader->PID              = (buf[1] & 0x1F) << 8 | buf[2];
  pheader->transport_scrambling_control  = buf[3] >> 6;
  pheader->adaption_field_control      = buf[3] >> 4 & 0x03;
  pheader->continuity_counter        = buf[3] & 0x03;
} 

例如要提取结构体中的adaption_field_control，因为它是第26~27位，也就是第3（基于0）字节的第2~3位（共两位），所以要取第3字节，然后右移2位（把右边多余的2位抛弃），再“与”3（屏蔽左边多余的位）。

 

 

==========================**PCR**================

http://dekst.awardspace.com/project/download/PCR.pdf

时间上的同步包括音频和视频上的同步，然而 在传输流（Transport Stream, TS）的传输过程中， 由于网络延迟、复接，以及在适配器（网卡）中适时的加 入了空包和兆帧初始化包（ Mega-frame Initialization Packet，MIP）等种种因素，使得附 带音频和视频时间信息的两个相邻 PCR 的相对位 置发生了改变，这将可能造成接收端解出的图像 出现马赛克和唇音不同步等现象，即 PCR 发生了 抖动，因此，在单频网适配器中，需要对接收到 的 PCR 信息进行校正。

 

**编码器中使用一个 27MHz 的系统时钟来产 生一系列时间标签，包括指示音频、视频正确显 示（PTS）和解码的时间(DTS)，以及采样过程中系统时钟本身 的瞬时值。**

在 TS 流中描述该系统时钟瞬时值的时 间标签称为节目参考时钟标签（PCR），是编码器 27MHz 系统时钟的 42 比特采样值。

解码器中也 有一个 27MHz 的系统时钟，它根据打包的基本码 流 (Packetized Elementary Stream, PES)中的显 示时间标签 (Presentation Time Stamp, PTS)和 解码时间标签 (Decoding Time Stamp, DTS)字段 所指示的时间进行解码和显示。

**如果前端编码器 的时钟与后端解码器中时钟“绝对”同步，那么 TS 传输流中的 PCR 就没有任何意义了**。

但是如 果“绝对”变为“相对”以后，它们之间的“微 小”误差经过长时间的累积（1~2 小时足以），机 顶盒中解码器就会因为自己的时钟“快”了而造 成 buffer 中没有数据（即停帧），或是因为时钟“慢” 了而造成 buffer 中数据溢出（即丢帧）。

所以**解码 器就需要用 TS 流中的 PCR 字段来不断修正自己 与编码器时钟之间的“微小”误差**。

同时 **TS 流经 过适配器时，在原有的 TS 流中插入了用于调整 速率的空包和控制TS流传输的MIP包，因此PCR 必须进行非均匀延迟修正**。

 

- **PCR的查找和提取**

**在 TS 流的传输过程中，并不是每一个 TS 包 （188 个字节）都带有 PCR 信息**，这样，在处理 流入单频网适配器中的 TS 流的 PCR 信息时，就 需要先查找到 PCR 信息，将其提取出来，然后再 对 PCR 信息进行修正。

 

![img](.\pic_resource\TS_note\TS_header.png)

**如上图所示，PCR是存在自适应区的。有没有自适应区由TS包头中的adaption_field_control字段控制。**

**如果有自适应区，那么其内容存放在TS流中数据域中，在有效负载(音视频数据)之前。**

 

图 1 给出了 TS 流的帧结构，由此可以看出， 要查找 PCR，首先应检查包头中自适应控制位**adaption_field_control**的 值，当其为“10”或“11”时，表示连续计数器后紧跟 着自适应区，当其为“00”或“01”时，就不存在自适 应区，那么，连续计数器后紧跟着的就是有效负 载。

 

当判定 TS 包中存在自适应区后，就查询自适应区中的 PCR 标志位是否为 1，如果是 1，则该 TS 包中有 PCR 信息，且 PCR 信息就存放在可选 字段的前 48 位中。

 

**4. PCR 改进校正算法**

对 PCR 字段进行校正的基本思路是在原始的 PCR 上加上一个校正值。一般校正值的计算公式 如下：

∆PCR = delact − delconst （4）

其中，delact是某 TS 流的 PCR 从进入本地系统到 离开系统所经历的实际延迟，delconst 是节目的所 有 PCR 使用的一个常数。

假定 PCR 进入适配器时，本地有一个以 27MHZ 时钟计数的计数器，此时该计数器的值记 为 PCRin；当 PCR 离开适配器时，计数器的值记 为 PCRout，

那么： ∆PCR = PCRout − PCRin （5）

![img](.\pic_resource\TS_note\PCR_calc.png)

 

**对 PCR 先做减法后做加法，中间的差值实质 上就是系统引入非恒定延时所需要校正补偿的 值，这样就间接地实现了 PCR 校正**。

按照上述原理，传统的 PCR 间接校正算法就 是在 TS 流进入单频网适配器时，经过 PCR 包查 找和 PCR 域定位，将 PCR 域中的值提取出来和 本地计数器的当前计数值相减，差值存入 FIFO 当中。

TS 流输出时，又一次对 PCR 包进行查找 和域定位，然后从 FIFO 中取出数据，和本地计数 器的当前值相加，将结果按照 TS 包的格式转换为6 个字节数据插入到 TS 流相应的 PCR 域里，从 而完成对 PCR 的校正。

 

这种设计方式和 PCR 直接校正算法（用 27MHZ 的计数器，直接记录 PCR 信息从流入适 配器到流出适配器的时间，然后将这段时间直接 在输出时加在原有的 PCR 值上）相比具有占用逻 辑资源少，不用记录与当前 PCR 相匹配的计数器 号，及时序控制相对简单等优点。

但是，由于本 文设计的是单频网适配器中的 PCR 校正，在适配 器中，对TS流进行去空包处理时用到了一个FIFO 作为缓冲器，若用上诉 PCR 间接算法的设计方式， 还将用到一个 FIFO，两个内部 FIFO 的使用将大 大提高对 FPGA 逻辑资源的占用。

另外，在 TS 输入和输出适配器时，都要进行 PCR 的查找和定 位，两个过程完全相同，这也同样增加了 FPGA 的逻辑资源占用。

为了减少 FPGA 的逻辑资源占用率，优化设 计，我们在对 TS 流进行第一次 PCR 查找和定位 以后，就在原有的每个字节前均加上一个标志位。 当定位到的 PCR 域时，将 PCR 域的每个字节前 的标志位置 1；其他情况下，每个字节前的标志位 均为 0。这样，在输出 TS 流进行第二次查找和定 位 PCR 时，只需看字节前的标志位为 1 还是为 0， 只对标志位为 1 的字节进行处理即可。在第一次 查找定位 PCR 信息后，将 PCR 值提取出来与本 地计数器做了减法，差值不再放入 FIFO 而是重 新插入 TS 流中；输出时再从 TS 流中取出这个 差值与本地计数器做加法，将结果再插回 TS 流， 完成 PCR 校正的间接算法。通过 TS 流本身来 传递减法差值，这样就既节省了一个 FIFO 所要 占用的逻辑资源，又避免了在减法差值存储过程 中对 FIFO 的读写控制，彻底杜绝了数据竞争冒 险的潜在危险，同时还简化了程序。



https://www.cnblogs.com/CoderTian/p/7198765.html

 ts流最早应用于数字电视领域，其格式非常复杂包含的配置信息表多达十几个，视频格式主要是mpeg2。苹果公司发明的http live stream流媒体是基于ts文件的，不过他大大简化了传统的ts流，只需要2个最基本的配置表PAT和PMT，再加上音视频内容就可以了，hls流媒体视频编码的主要格式为h264/mpeg4，音频为aac/mp3。

ts文件分为三层：ts层（Transport Stream）、pes层（Packet Elemental Stream）、es层（Elementary Stream）。es层就是音视频数据，pes层是在音视频数据上加了时间戳等对数据帧的说明信息，ts层是在pes层上加入了数据流识别和传输的必要信息。

![img](.\pic_resource\TS_note\TS_arch.png)

# 1.ts层

![img](.\pic_resource\TS_note\TS_stream.png)

 ts包大小固定为188字节，ts层分为三个部分：ts header、adaptation field、payload。ts header固定4个字节；adaptation field可能存在也可能不存在，主要作用是给不足188字节的数据做填充；payload是pes数据。

![img](.\pic_resource\TS_note\TS_packet.png)

## 1.1.ts header

| sync_byte                    | 8bit  | 同步字节，固定为0x47                                         |
| ---------------------------- | ----- | ------------------------------------------------------------ |
| transport_error_indicator    | 1bit  | 传输错误指示符，表明在ts头的adapt域后由一个无用字节，通常都为0，这个字节算在adapt域长度内 |
| payload_unit_start_indicator | 1bit  | 负载单元起始标示符，一个完整的数据包开始时标记为1            |
| transport_priority           | 1bit  | 传输优先级，0为低优先级，1为高优先级，通常取0                |
| pid                          | 13bit | pid值(Packet ID号码，唯一的号码对应不同的包)                 |
| transport_scrambling_control | 2bit  | 传输加扰控制，00表示未加密                                   |
| adaptation_field_control     | 2bit  | 是否包含自适应区，‘00’保留；‘01’为无自适应域，仅含有效负载；‘10’为仅含自适应域，无有效负载；‘11’为同时带有自适应域和有效负载。 |
| continuity_counter           | 4bit  | 递增计数器，从0-f，起始值不一定取0，但必须是连续的           |

ts层的内容是通过PID值来标识的，主要内容包括：PAT表、PMT表、音频流、视频流。解析ts流要先找到PAT表，只要找到PAT就可以找到PMT，然后就可以找到音视频流了。PAT表的PID值固定为0。PAT表和PMT表需要定期插入ts流，因为用户随时可能加入ts流，这个间隔比较小，通常每隔几个视频帧就要加入PAT和PMT。PAT和PMT表是必须的，还可以加入其它表如SDT（业务描述表）等，不过hls流只要有PAT和PMT就可以播放了。

- PAT表：他主要的作用就是指明了PMT表的PID值。
- PMT表：他主要的作用就是指明了音视频流的PID值。
- 音频流/视频流：承载音视频内容。

 PID是TS流中唯一识别标志，Packet Data是什么内容就是由PID决定的。如果一个TS流中的一个Packet的Packet Header中的PID是0x0000，那么这个Packet的Packet Data就是DVB的PAT表而非其他类型数据（如Video、Audio或其他业务信息）。下表给出了一些表的PID值，这些值是固定的，不允许用于更改。

| 表         | PID 值 |
| ---------- | ------ |
| PAT        | 0x0000 |
| CAT        | 0x0001 |
| TSDT       | 0x0002 |
| EIT,ST     | 0x0012 |
| RST,ST     | 0x0013 |
| TDT,TOT,ST | 0x0014 |

下面以一个TS流的其中一个Packet中的Packet Header为例进行说明：

|                    | 1                | 2    | 3    | 4    | 5            | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   | 25   | 26   | 27   | 28   | 29   | 30   | 31   | 32   | …    |
| ------------------ | ---------------- | ---- | ---- | ---- | ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Packet（十六进制） | 4                | 7    | 0    | 7    | e            | 5    | 1    | 2    | …    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Packet（二进制）   | 0                | 1    | 0    | 0    | 0            | 1    | 1    | 1    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 0    | 1    | 0    | …    |
| Packet Header 信息 | 1 sync_byte=0x47 | 2    | 3    | 4    | 5 PID=0x07e5 | 6    | 7    | 8    | …    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

sync_byte=01000111,             就是0x47,这是DVB TS规定的同步字节,固定是0x47.

transport_error_indicator=0,        表示当前包没有发生传输错误.

payload_unit_start_indicator=0,    含义参考ISO13818-1标准文档

transport_priority=0,             表示当前包是低优先级.

PID=00111 11100101即0x07e5,    Video PID

transport_scrambling_control=00,   表示节目没有加密

adaptation_field_control=01        即0x01,具体含义请参考ISO13818-1

continuity_counte=0010           即0x02,表示当前传送的相同类型的包是第3个

## 1.2.adaption

| adaptation_field_length | 1B   | 自适应域长度，后面的字节数                                   |
| ----------------------- | ---- | ------------------------------------------------------------ |
| flag                    | 1B   | 取0x50表示包含PCR或0x40表示不包含PCR                         |
| PCR                     | 5B   | Program Clock Reference，节目时钟参考，用于恢复出与编码端一致的系统时序时钟STC（System Time Clock）。 |
| stuffing_bytes          | xB   | 填充字节，取值0xff                                           |

自适应区的长度要包含传输错误指示符标识的一个字节。pcr是节目时钟参考，pcr、dts、pts都是对同一个系统时钟的采样值，pcr是递增的，因此可以将其设置为dts值，音频数据不需要pcr。如果没有字段，ipad是可以播放的，但vlc无法播放。打包ts流时PAT和PMT表是没有adaptation field的，不够的长度直接补0xff即可。视频流和音频流都需要加adaptation field，通常加在一个帧的第一个ts包和最后一个ts包里，中间的ts包不加。

## 1.3.PAT格式(Program Association Table，节目关联表)

PAT表定义了当前TS流中所有的节目，其PID为0x0000，它是PSI的根节点，要查寻找节目必须从PAT表开始查找。

| table_id                 | 8b   | PAT表固定为0x00                                           |
| ------------------------ | ---- | --------------------------------------------------------- |
| section_syntax_indicator | 1b   | 固定为1                                                   |
| zero                     | 1b   | 固定为0                                                   |
| reserved                 | 2b   | 固定为11                                                  |
| section_length           | 12b  | 后面数据的长度                                            |
| transport_stream_id      | 16b  | 传输流ID，固定为0x0001                                    |
| reserved                 | 2b   | 固定为11                                                  |
| version_number           | 5b   | 版本号，固定为00000，如果PAT有变化则版本号加1             |
| current_next_indicator   | 1b   | 固定为1，表示这个PAT表可以用，如果为0则要等待下一个PAT表  |
| section_number           | 8b   | 固定为0x00                                                |
| last_section_number      | 8b   | 固定为0x00                                                |
| 开始循环                 |      |                                                           |
| program_number           | 16b  | 节目号为0x0000时表示这是NIT，节目号为0x0001时,表示这是PMT |
| reserved                 | 3b   | 固定为111                                                 |
| PID                      | 13b  | 节目号对应内容的PID值                                     |
| 结束循环                 |      |                                                           |
| CRC32                    | 32b  | 前面数据的CRC32校验码                                     |

通过一段TS流中一个Packet分析PAT表，这里我们分析一段TS流其中一个Packet的Packet Data部分：

首先给出一个数据包，其数据如下：

| Packet Header       | Packet Data                                                  |
| ------------------- | ------------------------------------------------------------ |
| 0x47 0x40 0x00 0x10 | 0000 b0 11 00 01 c1 00 00 00 00 e0 1f 00 01 e1 00 24 ac48 84 ff ff…… ff ff |

分析Packet Header如下表所示：

|                    | 1                | 2    | 3    | 4    | 5            | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   | 25   | 26   | 27   | 28   | 29   | 30   | 31   | 32   | …    |
| ------------------ | ---------------- | ---- | ---- | ---- | ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Packet（十六进制） | 4                | 7    | 4    | 0    | 0            | 0    | 1    | 0    | …    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Packet（二进制）   | 0                | 1    | 0    | 0    | 0            | 1    | 1    | 1    | 0    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 0    | …    |
| Packet Header Bits | 1 sync_byte=0x47 | 2    | 3    | 4    | 5 PID=0x0000 | 6    | 7    | 8    | …    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

 根据包头数据格式，我们可以知晓整个数据包的属性，列表如下：

| sync_byte                    | 0x47   | 固定同步字节                                                 |
| ---------------------------- | ------ | ------------------------------------------------------------ |
| transport_error_indicator    | “0”    | 没有传输错误                                                 |
| payload_unit_start_indicator | “1”    | 在前4个字节后会有一个调整字节。所以实际数据应该为去除第一个字节后的数据。即上面数据中红色部分不属于有效数据包。 |
| transport_priority           | “0”    | 传输优先级低                                                 |
| PID                          | 0x0000 | PID=0x0000说明数据包是PAT表信息                              |
| transport_scrambling_control | “00”   | 未加密                                                       |
| adaptation_field_control     | “01”   | 附加区域控制                                                 |
| continuity_counte            | “0000” | 包递增计数器                                                 |

如上表所示，我们可以知道，首先Packet的Packet Data是PAT信息表，因为其PID为0x0000，并且在包头后需要除去一个字节才是有效数据（payload_unit_start_indicator="1"）。这样，Packet Data就应该是“00 b0 11 00 01 c1 00 00 00 00 e0 1f 00 01 e1 00 24 ac48 84 ff ff …… ff ff”。

| Packet Data分析                                        |      |                             |                                                              |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| ------------------------------------------------------ | ---- | --------------------------- | ------------------------------------------------------------ | ----------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 第n个字节                                              | 1    | 2                           | 3                                                            | 4                       | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   | …    |
| Packet Data(除去开头的0x00)                            | 00   | b0                          | 11                                                           | 00                      | 01   | c1   | 00   | 00   | 00   | 00   | e0   | 1f   | 00   | 01   | e1   | 00   | 24   | ac   | 48   | 84   | …    |
| 字段名                                                 | 位   | 具体值                      | 次序                                                         | 说明                    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| table_id                                               | 8    | 0000                        | 第1个字节 0000 0000B(0x00)                                   | PAT的table_id只能是0x00 |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| section_syntax_indicator                               | 1    | 1                           | 第2、3个字节1011 0000 0001 0001B(0xb0 11)                    | 段语法标志位，固定为1   |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| zero                                                   | 1    | 0                           |                                                              |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| reserved                                               | 2    | 11                          |                                                              |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| section_length                                         | 12   | 0000 0001 0001B=0x011=17    | 段长度为17字节                                               |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| transport_stream_id                                    | 16   | 0x0001                      | 第4、5个字节 0x00 0x01                                       |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| reserved                                               | 2    | 11                          | 第6个字节 1100 0001B(0xc1)                                   |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| version_number                                         | 5    | 00000                       | 一旦PAT有变化，版本号加1                                     |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| current_next_indicator                                 | 1    | 1                           | 当前传送的PAT表可以使用，若为0则要等待下一个表               |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| section_number                                         | 8    | 0x00                        | 第7个字节0x00                                                |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| last_section_number                                    | 8    | 0x00                        | 第8个字节 0x00                                               |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| 开始循环                                               |      |                             |                                                              |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| program_number                                         | 16   | 0x0000-第一次               | 2个字节(0x00 00)                                             | 节目号                  |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| reserved                                               | 3    | 111                         | 2个字节1110 0000 0001 1111B(0xe0 1f)                         |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| network_id(节目号为0时)program_map_PID(节目号为其他时) | 13   | 0 0000 0001 1111B=31-第一次 | 节目号为0x0000时,表示这是NIT，PID=0x001f，即31节目号为0x0001时,表示这是PMT，PID=0x100，即256 |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| 结束循环                                               |      |                             |                                                              |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| CRC_32                                                 | 32   | --                          | 4个字节                                                      |                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

 由以上几个表可以分析出PAT表和PMT表有着内在的联系。也就是之前提到的。PAT表描述了当前流的NIT（Network Information Table，网络信息表）中的PID、当前流中有多少不同类型的PMT表及每个PMT表对应的频道号。

## 1.4.PMT格式( Program Map Table，节目映射表 )

| table_id                 | 8b   | PMT表取值随意，0x02                                          |
| ------------------------ | ---- | ------------------------------------------------------------ |
| section_syntax_indicator | 1b   | 固定为1                                                      |
| zero                     | 1b   | 固定为0                                                      |
| reserved                 | 2b   | 固定为11                                                     |
| section_length           | 12b  | 后面数据的长度                                               |
| program_number           | 16b  | 频道号码，表示当前的PMT关联到的频道，取值0x0001              |
| reserved                 | 2b   | 固定为11                                                     |
| version_number           | 5b   | 版本号，固定为00000，如果PAT有变化则版本号加1                |
| current_next_indicator   | 1b   | 固定为1                                                      |
| section_number           | 8b   | 固定为0x00                                                   |
| last_section_number      | 8b   | 固定为0x00                                                   |
| reserved                 | 3b   | 固定为111                                                    |
| PCR_PID                  | 13b  | PCR(节目参考时钟)所在TS分组的PID，指定为视频PID              |
| reserved                 | 4b   | 固定为1111                                                   |
| program_info_length      | 12b  | 节目描述信息，指定为0x000表示没有                            |
| 开始循环                 |      |                                                              |
| stream_type              | 8b   | 流类型，标志是Video还是Audio还是其他数据，h.264编码对应0x1b，aac编码对应0x0f，mp3编码对应0x03 |
| reserved                 | 3b   | 固定为111                                                    |
| elementary_PID           | 13b  | 与stream_type对应的PID                                       |
| reserved                 | 4b   | 固定为1111                                                   |
| ES_info_length           | 12b  | 描述信息，指定为0x000表示没有                                |
| 结束循环                 |      |                                                              |
| CRC32                    | 32b  | 前面数据的CRC32校验码                                        |

通过一段TS流中一个Packet分析PMT表，通过分析一段TS流的数据包Packet来学习PMT表。下面给出了一段TS流数据中的一个Packet（十六进制数）

| Packet Header       | Packet Data                                                  |
| ------------------- | ------------------------------------------------------------ |
| 0x47 0x43 0xe8 0x12 | 00 02 b0 12 00 01 c1 00 00 e3 e9 f0 00 1b e3 e9 f0 00 f0 af b4 4f ff ff…… ff ff |

 首先解析Packet Header，分析如下：

|                    | 1                | 2    | 3    | 4    | 5            | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   | 25   | 26   | 27   | 28   | 29   | 30   | 31   | 32   | …    |
| ------------------ | ---------------- | ---- | ---- | ---- | ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Packet（十六进制） | 4                | 7    | 4    | 3    | e            | 8    | 1    | 2    | …    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Packet（二进制）   | 0                | 1    | 0    | 0    | 0            | 1    | 1    | 1    | 0    | 1    | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 0    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 1    | 0    | …    |
| Packet Header Bits | 1 sync_byte=0x47 | 2    | 3    | 4    | 5 PID=0x03e8 | 6    | 7    | 8    | …    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

 

| Packet Header分析 |                                    |        |                                                              |
| ----------------- | ---------------------------------- | ------ | ------------------------------------------------------------ |
|                   | Packet Header：0x47 0x40 0x00 0x10 |        |                                                              |
| 1                 | sync_byte                          | 0x47   | 固定同步字节                                                 |
| 2                 | transport_error_indicator          | “0”    | 没有传输错误                                                 |
| 3                 | payload_unit_start_indicator       | “1”    | 在前4个字节后会有一个调整字节。所以实际数据应该为去除第一个字节后的数据。 |
| 4                 | transport_priority                 | “0”    | 传输优先级低                                                 |
| 5                 | PID                                | 0x03e8 | PID=0x03e8说明数据包是PMT表信息                              |
| 6                 | transport_scrambling_control       | “00”   | 未加密                                                       |
| 7                 | adaptation_field_control           | “01”   | 附加区域控制                                                 |
| 8                 | continuity_counte                  | “0010” | 包递增计数器                                                 |

因为payload_unit_start_indicator=‘1’，在解析数据包的时候需要去除Packet Data的第一个字节。下面是对Packet Data的详细解析：

| PMT表的Packet Data分析   |      |                      |                                                              |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| ------------------------ | ---- | -------------------- | ------------------------------------------------------------ | --------------------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 第n个字节                | 1    | 2                    | 3                                                            | 4                                       | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   | …    |
| Packet Data              | 02   | b0                   | 12                                                           | 00                                      | 01   | c1   | 00   | 00   | e3   | e9   | f0   | 00   | 1b   | e3   | e9   | f0   | 00   | f0   | 1b   | e3   | …    |
| 字段名                   | 位数 | 具体值               | 次序                                                         | 说明                                    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| table_id                 | 8    | 0x02                 | 第1个字节                                                    |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| section_syntax_indicator | 1    | 1B                   | 第2、3个字节1011 0000 0001 0010B=0xb012                      | 段语法标志                              |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| zero                     | 1    | 0B                   |                                                              |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| reserved                 | 2    | 11B=0x03             |                                                              |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| section_length           | 12   | 0000 0001 0010B=0x12 | 段长度,从program_number开始,到CRC_32(含)的字节总数           |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| program_number           | 16   | 0x0001               | 第4、5个字节 0x00 01                                         | 频道号码,表示当前的PMT关联到的频道      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| reserved                 | 2    | 11B=0x03             | 第6个字节1100 0001B=0xc1                                     |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| version_number           | 5    | 00000B=0x00          | 版本号码,如果PMT内容有更新,则它会递增1通知解复用程序需要重新接收节目信息 |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| current_next_indicator   | 1    | 1B=0x01              | 当前未来标志符                                               |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| section_number           | 8    | 0x00                 | 第7个字节0x00                                                | 当前段号码                              |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| last_section_number      | 8    | 0x00                 | 第8个字节 0x00                                               | 最后段号码,含义和PAT中的对应字段相同    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| reserved                 | 3    | 111B=0x07            | 第9、10个字节1110 0011 1110 1001B=0xe3e9                     |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| PCR_PID                  | 13   | 000111110B=0x3e9     | PCR(节目参考时钟)所在TS分组的PID                             |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| reserved                 | 4    | 1111B=0x0f           | 第11、12个字节1111 0000 0000 0000=0xf000                     |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| program_info_length      | 12   | 000000000000B=0x000  | 节目信息长度(之后的是N个描述符结构,一般可以忽略掉,这个字段就代表描述符总的长度,单位是Bytes)紧接着就是频道内部包含的节目类型和对应的PID号码了 |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| stream_type              | 8    | 0x1b                 | 第13个字节 0x1b                                              | 流类型,标志是Video还是Audio还是其他数据 |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| reserved                 | 3    | 111B=0x07            | 第14、15个字节1110 0011 1110 1001B=0xe3e9                    |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| elementary_PID           | 13   | 000111110 1001=0x3e9 | 该节目中包括的视频流，音频流等对应的TS分组的PID              |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| reserved                 | 4    | 1111B=0x0f           | 第16、17个字节1111 0000 0000 0000B=0xf000                    |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| ES_info_length           | 12   | 0000 0000 0000=0x000 |                                                              |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| CRC                      | 32   | ——                   | ——                                                           |                                         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

## 1.4.pes层

pes层是在每一个视频/音频帧上加入了时间戳等信息，pes包内容很多，我们只留下最常用的。 

| pes start code    | 3B   | 开始码，固定为0x000001                                       |
| ----------------- | ---- | ------------------------------------------------------------ |
| stream id         | 1B   | 音频取值（0xc0-0xdf），通常为0xc0 视频取值（0xe0-0xef），通常为0xe0 |
| pes packet length | 2B   | 后面pes数据的长度，0表示长度不限制， 只有视频数据长度会超过0xffff |
| flag              | 1B   | 通常取值0x80，表示数据不加密、无优先级、备份的数据           |
| flag              | 1B   | 取值0x80表示只含有pts，取值0xc0表示含有pts和dts              |
| pes data length   | 1B   | 后面数据的长度，取值5或10                                    |
| pts               | 5B   | 33bit值                                                      |
| dts               | 5B   | 33bit值                                                      |

pts是显示时间戳、dts是解码时间戳，视频数据两种时间戳都需要，音频数据的pts和dts相同，所以只需要pts。有pts和dts两种时间戳是B帧引起的，I帧和P帧的pts等于dts。如果一个视频没有B帧，则pts永远和dts相同。从文件中顺序读取视频帧，取出的帧顺序和dts顺序相同。dts算法比较简单，初始值 + 增量即可，pts计算比较复杂，需要在dts的基础上加偏移量。

   音频的pes中只有pts（同dts），视频的I、P帧两种时间戳都要有，视频B帧只要pts（同dts）。打包pts和dts就需要知道视频帧类型，但是通过容器格式我们是无法判断帧类型的，必须解析h.264内容才可以获取帧类型。

## 1.5.es层

es层就是音视频裸数据了，常用的音频编码格式为AAC，视频编码格式为H.264

# 2.打包H.264和AAC为TS

对于H.264视频而言，每一帧的时间长度为

 frame_duration = 1000/fps

当fps为25时，一帧时间为40ms

对于AAC音频而言，每一帧的时间长度为

音频帧的播放时间=一个AAC帧对应的采样样本的个数/采样频率(单位为s)
一帧 1024个 sample。采样率 Samplerate 44100KHz，每秒44100个sample, 所以根据公式  音频帧的播放时间=一个AAC帧对应的采样样本的个数/采样频率
当前AAC一帧的播放时间是= 1024*1000000/44100= 22.32ms(单位为ms)

理论上的音视频(播放)同步是这样的：
由此得到了每一帧数据的持续时间，音视频交叉存储在容器中：一个时间轴：
时间轴：0  22.32  40   44.62  66.96  80   89.16   111.48  120    ................
音  频 ：0  22.32      44.62  66.96       89.16   111.48        ................
视  频 ：0       40               80                  120    ................
即视频的持续时间相加 和音频的持续时间相加作比较，谁小写入哪个。

(自己的方法)

音频数据（AAC 48k）     21.33   42.44  63.99      85.32

视频数据（H264 25fps）        40            80

时间轴              ------------------------------------------->

（ts容器）循环做（写一帧视频，然后写一帧音频，然后视频的时间减去音频的时间，如果大于一帧音频的时间，就多写一帧音频，知道视频多出来的时间小于一帧音频）

**使用 Elecard Stream Analyzer 可以分析TS流**



# [简单实现h264转ts](https://www.cnblogs.com/dyan1024/p/10224538.html)

转载注明出处：https://www.cnblogs.com/dyan1024/p/10224538.html

最近一个项目中需要在项目中临时嵌入h264裸流编码成ts的代码，但是以前从没接触过视频，先是在网上搜索了2~3天（主要是想找个能用demo看看编码流程借鉴下）。只找到ffmpeg命令行转码的，ffmpeg也没接触过没那时间去分析怎么转的，而且我们不想使用ffmpeg这个库，之后还要将编码过程从ffmpeg中提取出来，又是一个比较大的难点。总之没头苍蝇一样搜索心累，耐心用完了，算了算了看看格式自己编好了。

然后又用了2~3天初步完成了转码，因为网上很难找到这样的demo可以参考，所以有了这篇文章。

以下是参考博客及规范链接：

[hls之m3u8、ts、h264、AAC流格式详解](https://blog.csdn.net/heiyeshuwu/article/details/52316738)

[将H264与AAC打包Ipad可播放的TS流的总结](https://www.cnblogs.com/wangqiguo/archive/2013/03/29/2987949.html)

[TS协议解析第一部分（PAT）](https://blog.csdn.net/u013354805/article/details/51578457)

[TS协议解析第二部分（PMT）](https://blog.csdn.net/u013354805/article/details/51586086)

[TS协议解析第三部分（PES）](https://blog.csdn.net/u013354805/article/details/51591229)

[TS协议解析第四部分（adaptation field）](https://blog.csdn.net/u013354805/article/details/51683830)

[ISO.IEC-13818-1-中文版规范](https://wenku.baidu.com/view/152800d7370cba1aa8114431b90d6c85ec3a880d.html)

[ts crc32 验证与计算](https://blog.csdn.net/zhengfl/article/details/23250769)

参考TS协议解析4连是因为手头没有ts格式的二进制文件的实际参考，主要是为了对比实际生成的二进制文件与自己理解的文件格式是否有差别。

其中第二个参考博客那张图对于直观理解hls的ts包格式很有帮助，因此将这张图片复制了过来，还读了一些其他博客，以上只是个人感觉对于完成手动编码比较关键的部分。

![img](.\pic_resource\TS_note\TS_info.jpg)